/*------------------------------------------------------------------------------------------
   
   Theremin Tone Digitizer

This is an experiment in "quantizing" the notes that are played by a Theremin, in 
particular, by the popular Moog Etherwave from the late 1990s. 

The rationale was that a Theremin is difficult to play because it's hard to hit 
normal notes, since it plays every frequency in between the notes too. So if we 
constrain it to play *only* normal notes, it should be easier to play. 

Well, it doesn't work that way. You might even argue that it makes it worse, since 
errors are a complete note away from what you wanted, which sounds really bad. But it 
was a noble experiment, and maybe someone can figure out a tweak to the 
note-generating algorithm that makes it better. 

Here's how it works: We get a signal which tracks the transitions of the analog 
waveform generated by the Theremin. We determine the transition timing, and from 
that, deduce the waveform period. 

We then find the closest note in either the chromatic (12-tone) or octatonic (8-tone) 
scale, depending on the setting of an option switch. If the note persists for a while 
(50 msec, say, in order to avoid playing unintended notes on the way to a note we 
want), we generate a square wave at that frequency. It is then sent to the 
voltage-controlled amplifier in the Theremin for sound shaping and volume modulation, 
and then on to the speaker. 

This is implemented on a breadboard that has an Arduino Nano, a voltage comparator 
with hysteresis for analyzing the Theremin signal, and a level-shifter to create a 
negative signal for the Theremin from the square wave we output. 

We connect to the Theremin using its 8-pin auxiliary connector, with the unused "AUX" 
pin connected to the input of the voltage-controlled amplifier, and the trace between 
the "AUDIO" output of the detector and the VCA broken so that we can inject our own
signal. 

To honor its history, I built my Theremin inside a 1940s-eras tabletop radio enclosure.

Jun 2009, L. Shustek: first version
Mar 2022, L. Shustek: update for better analog hardware; implement note persistence

(C) L. Shustek, 2009, 2022
------------------------------------------------------------------------------------------*/

#define DEBUG false

#include "TimerOne.h"

#define ledPin 13               // the NANO's LED is connected to digital D13
#define AudioInPin 2            // Audio in from Theremin is on D2
#define AudioOutPin 9           // Our generated audio is output on D9
#define SenseSwitch1 8          // Sense switch 1 is D8
#define SenseSwitch2 7          // Sense switch 2 is D7

#define WAITLIMIT_USEC 100000UL // .1 second max wait for input transition
#define WAITCOUNT 10000         // # of loops before checking WaitLimit
#define NOTE_MIN_MSEC 50        // skip notes lasting less than this

// chromatic 12-tone scale
unsigned notes12[] = {  // period, frequency, note
   36364, // 27.5, C
   34323, // 29.1, C#
   32396, // 30.9, D
   30578, // 32.7, D#
   28862, // 34.6, E
   27242, // 36.7, F
   25713, // 38.9, F#
   24270, // 41.2, G
   22908, // 43.7, G#
   21622, // 46.2, A
   20408, // 49.0, A#
   19263, // 51.9, B
   18182, // 55.0, C
   17161, // 58.3, C#
   16198, // 61.7, D
   15289, // 65.4, D#
   14431, // 69.3, E
   13621, // 73.4, F
   12856, // 77.8, F#
   12135, // 82.4, G
   11454, // 87.3, G#
   10811, // 92.5, A
   10204, // 98.0, A#
   9631, // 103.8, B
   9091, // 110.0, C
   8581, // 116.5, C#
   8099, // 123.5, D
   7645, // 130.8, D#
   7215, // 138.6, E
   6810, // 146.8, F
   6428, // 155.6, F#
   6067, // 164.8, G
   5727, // 174.6, G#
   5405, // 185.0, A
   5102, // 196.0, A#
   4816, // 207.7, B
   4545, // 220.0, C
   4290, // 233.1, C#
   4050, // 246.9, D
   3822, // 261.6, D#
   3608, // 277.2, E
   3405, // 293.7, F
   3214, // 311.1, F#
   3034, // 329.6, G
   2863, // 349.2, G#
   2703, // 370.0, A
   2551, // 392.0, A#
   2408, // 415.3, B
   2273, // 440.0, C
   2145, // 466.2, C#
   2025, // 493.9, D
   1911, // 523.3, D#
   1804, // 554.4, E
   1703, // 587.3, F
   1607, // 622.3, F#
   1517, // 659.3, G
   1432, // 698.5, G#
   1351, // 740.0, A
   1276, // 784.0, A#
   1204, // 830.6, B
   1136, // 880.0, C
   1073, // 932.3, C#
   1012, // 987.8, D
   956, // 1046.5, D#
   902, // 1108.7, E
   851, // 1174.7, F
   804, // 1244.5, F#
   758, // 1318.5, G
   716, // 1396.9, G#
   676, // 1480.0, A
   638, // 1568.0, A#
   602, // 1661.2, B
   568, // 1760.0, C
   536, // 1864.7, C#
   506, // 1975.5, D
   478, // 2093.0, D#
   451, // 2217.5, E
   426, // 2349.3, F
   402, // 2489.0, F#
   379, // 2637.0, G
   358, // 2793.8, G#
   338, // 2960.0, A
   319, // 3136.0, A#
   301, // 3322.4, B
   0 };

// octatonic 8-tone scale
unsigned notes8[] = {  // period, frequency, note
   36364, // 27.5, C
   32396, // 30.9, D
   28862, // 34.6, E
   27242, // 36.7, F
   24270, // 41.2, G
   21622, // 46.2, A
   19263, // 51.9, B
   18182, // 55.0, C
   16198, // 61.7, D
   14431, // 69.3, E
   13621, // 73.4, F
   12135, // 82.4, G
   10811, // 92.5, A
   9631, // 103.8, B
   9091, // 110.0, C
   8099, // 123.5, D
   7215, // 138.6, E
   6810, // 146.8, F
   6067, // 164.8, G
   5405, // 185.0, A
   4816, // 207.7, B
   4545, // 220.0, C
   4050, // 246.9, D
   3608, // 277.2, E
   3405, // 293.7, F
   3034, // 329.6, G
   2703, // 370.0, A
   2408, // 415.3, B
   2273, // 440.0, C
   2025, // 493.9, D
   1804, // 554.4, E
   1703, // 587.3, F
   1517, // 659.3, G
   1351, // 740.0, A
   1204, // 830.6, B
   1136, // 880.0, C
   1012, // 987.8, D
   902, // 1108.7, E
   851, // 1174.7, F
   758, // 1318.5, G
   676, // 1480.0, A
   602, // 1661.2, B
   568, // 1760.0, C
   506, // 1975.5, D
   451, // 2217.5, E
   426, // 2349.3, F
   379, // 2637.0, G
   338, // 2960.0, A
   301, // 3322.4, B
   0 };

void setup() {                   // run once, when the sketch starts
   pinMode(ledPin, OUTPUT);      // sets the digital pins
   pinMode(AudioOutPin, OUTPUT);
   pinMode(AudioInPin, INPUT);
   pinMode(SenseSwitch1, INPUT);
   pinMode(SenseSwitch2, INPUT);
   Timer1.initialize();         // initialize timer1
   if (DEBUG) {
      delay(500);
      Serial.begin(115200);
      delay(500);
      Serial.println("Theremin"); }
   //Timer1.pwm(AudioOutPin, 512, 4000); // pin, duty (0..1023), period in usec
}

// Wait for the audio input pin, which is the output of a voltage comparator,
// to be a specified value.  Return FALSE if timeout.

boolean wait_pin (int high_or_low) {
   unsigned long start_time = micros();
   do {
      for (int loopcount = 0; loopcount < WAITCOUNT; ++loopcount) {
         if (digitalRead(AudioInPin) == high_or_low) {
            //delayMicroseconds(10); // debounce comparator output
            //if (digitalRead(AudioInPin) == high_or_low)
            return true; } } }
   while (micros() - start_time < WAITLIMIT_USEC);
   return false; }

// Measure the current theremin-generated note

#define  NUM_PERIODS 3  // number of periods to average over
unsigned int read_note_period() {
   unsigned long start_time, last_time;
   // first look for a low-to-high transition
   if (!wait_pin(LOW)) return 0;
   if (!wait_pin(HIGH)) return 0;
   // start a timer and wait for NUM_PERIODS more low-to-high transitions
   start_time = last_time = micros();
   for (int cnt = 0; cnt < NUM_PERIODS; ++cnt) {
      if (!wait_pin(LOW)) return 0;
      if (!wait_pin(HIGH)) return 0;
      if (DEBUG) {
         unsigned long timenow = micros();
         Serial.print(timenow - last_time); Serial.print(' ');
         last_time = timenow; } }
   unsigned long time = (micros() - start_time) / NUM_PERIODS; // compute the average
   if (DEBUG) Serial.println(time);
   if (time > 0xffffUL) return 0; // truncate to 16 bits
   else return (unsigned) time; }

void loop() {
   static bool playing = false;
   static bool newnote = false;
   static unsigned prev_note = 0;
   static unsigned long note_started_msec;

   // Find the closest normalized note to the Theremin-generated note.
   // If it has changed, play it, but only if it persists for a while.

   unsigned period_in = read_note_period();
   if (period_in == 0) { // not seeing transitions
      Timer1.disablePwm(AudioOutPin);
      playing = false;
      digitalWrite(ledPin, LOW); }
   else { // we're seeing transitions: find the note
      unsigned note;
      for (int note_ndx = 0; ; ++note_ndx) {
         if (digitalRead(SenseSwitch1) == HIGH)
            note = notes8[note_ndx];
         else
            note = notes12[note_ndx];
         if (period_in >= note) break; }
      if (note != 0 && note != prev_note) { // starting a new note
         if (!playing) {
            playing = true;
            digitalWrite(ledPin, HIGH); }
         newnote = true;
         note_started_msec = millis();
         prev_note = note; }
      if (newnote && millis() - note_started_msec > NOTE_MIN_MSEC) {
         Timer1.pwm(AudioOutPin, 512, note); // it has persisted: play it
         newnote = false; } } }
//*
